// * 실행컨텍스트 *
// 자바스크립트는 해당 코드를 실행시킨다.
// 코드가 실행되면, 전역 컨텍스트가 생성되고, 변수객체화,스코프체인 생성 초기화, this바인딩이 된다.
// 함수는 실행될때마다 함수 컨텍스트가 생성되고, 위와 같다.


// 코드가 실행되면 전역컨텍스트가 생성.
// 코드 문맥을 기준으로 렉시컬 스코프가 생기고, 상위스코프가 결정된다.
// 밑의 코드에서 전역컨텍스트가 생성되면, 전역 스코프에 환경레코드에는 a,b,c, function print 가 있다.
// 만약 print 라는 함수를 실행 시키면, 함수 컨텍스트가 실행되고, 환경레코드에 d, innerPrint , 가 있다.

var a = 1;
const b = 2;
let c = 3;

function print(){
    const d = 4;
    const innerPrint = () =>{
         let e = 5;
         const innerPrint2 = () =>{
             console.log(e); // 6. 해당되는 innerPrint2 스코프에서 e를 찾으려고 하지만 없음 -> outer 참조로 상위스코프인 innerPrint 스코프의 환경레코드에서 e를 검색  -> e = 5;
         }
         console.log(d); // 4. 해당되는 innerPrint 스코프에서 d를 찾으려고 하지만 없음 -> outer 참조로 상위스코프인 print 스코프의 환경레코드에서 d를 검색  -> d = 4;
         innerPrint2();  // 5. 함수 실행 -> 함수 컨텍스트 생성 -> innerPrint2 스코프 환경레코드가 만들어짐
    }
    console.log(a); // 2.해당되는 print 스코프에서 a를 찾으려고하지만 없음 -> outer 참조로 상위스코프인 전역스코프의 환경레코드에서 a를 검색 -> a = 1;
    innerPrint(); //  3.함수 실행 -> 함수 컨텍스트 생성 -> innerPrint 스코프 환경레코드가 만들어짐.
}
print(); // 1. 함수 실행 - > 함수 컨텍스트 생성 -> print 스코프 환경레코드가 만들어짐

// ** 정리 **
// 스코프는 해당되는 식별자를 검색하는 매커니즘이다.
// 식별자를 검색할 때, 먼저 해당 스코프의 환경레코드에서 검색해보고,
// 없으면 상위 스코프의 환경레코드에서 검색해보고, 없으면 상위의 상위 스코프에서 검색한다.
// 마지막으로 전역 스코프에서 까지도 식별자를 검색할 수 없으면 error
// 이렇게 식별자를 검색할때 꼬리에 꼬리를 물어 검색하는것이 마치 체인처럼 되있다해서
// 이것을 스코프 체인이라고한다.


// 스코프
// 스코프는 참조대상 식별자(identifier)를 찾아 내기 위한 규칙이다.

// 변수는 전역 또는 코드블록, 함수 내에 선언하며, 자신이 어디에 선언됐는지에 의해 유효한 범위를 갖게 된다.

// const a = 1;
// function print(){
//    const a = 2;
//    console.log(a);  
// }
// print();
// console.log(a);
// 위 코드를 실행하게 되면 각각 a는 어떻게 출력이 될까?

// print() 실행
// print 함수 내부의 console.log(a) 는 2를 출력
// print 함수가 콜 스택에서 제거
// 전역의 console.log(a) 는 1를 출력
// 왜 이렇게 실행이 되는지 스코프의 관점에서 알아보자.

// 자바스크립트에서 스코프를 구분해보면 2가지로 나눌 수 있다.

//   1. 전역 스코프 (Global scope)

//   2. 지역 스코프 (Local scope / Funtion-level scope)

// 또, 변수 입장에서 구분하면 2가지로 나눌 수 있다.

//   1. 전역 변수 (Global variable)

//   2. 지역 변수 (Local variable)

// 자바 스크립트는 함수 레벨 스코프를 사용한다.
// 변수는 자기가 선언된 위치에 따라 스코프를 가지게 되는데, 위 코드의 첫 줄의 변수 a는 전역 스코프를 갖는 전역 변수가 되고, print 함수 내부의 변수 a는 함수 print의 스코프를 갖는 지역변수가 된다.

// 여기서 중요한 것은 전역변수는 코드 어디에서나 접근이 가능하고, 함수 print 내부의 변수 a는 오직 함수 내부 에서만 접근이 가능하다.

// 그리고 위 코드와 같이 함수 print 내부에서 변수 a를 찾으려고 할 때, 지역변수와 더 상위 스코프인 전역 변수의 변수명이 중복될때 지역변수를 우선으로 참조한다.


// 렉시컬 스코프(Lexical scope)
// 렉시컬 스코프는 함수를 어디서 호출했는에따라 스코프가 결정되는게 아니라, 함수를 어디에 선언했는지에 따라 스코프가 결정되는 것을 말한다.

// 자바 스크립트는 렉시컬 스코프를 따른다.

// const a = 1;
// function print1(){
//   const a = 2;
//   print2();
// }
// function print2(){
//   console.log(a);
// }
// print1();
// console.log(a);
// 위와 같은 코드에서 각각의 스코프를 알아보자.

// 먼저 이 코드를 실행하면 결과가 어떻게 될까?

// 함수 print1 실행
// 함수 print1 내부의 함수 print2 실행
// 함수 print2 내부의 console.log(a) 실행
// 함수 print2 콜 스택에서 제거
// 함수 print1 콜 스택에서 제거
// 마지막 줄의 console.log(a) 실행
// 실행 순서는 다음과 같다. 과연 출력은 어떻게 될까?

// 만약 자바스크립트가 렉시컬 스코프를 따르지 않는다면 결과는 2 1 이 출력이 될 것이다.

// 자바스크립트는 렉시컬 스코프를 따르기 때문에 결과는 1 1 이 출력이 된다. 

// 렉시컬 스코프는 함수가 호출되었는지는 스코프에 아무런 의미를 주지 않는다.

// 위 코드에서 함수 print1 과 print2 는 전역에 선언이 되었다. 따라서, 함수 print1 과 print2 의 상위 스코프는 전역 스코프이고, 함수 print1 내부의 함수 print2 가 실행되어도 함수 print2 내부에서 a를 찾으려고 할 때 전역변수인 첫 줄 a 를 찾게 되는 것이다.

// 스코프 체인 (scope chain)
// const a = 1;
// function print(){
//    const b = 2;
//    function innerPrint(){
//       console.log(a,b);
//    }
//    innerPrint();
// }
// print();
// 다음 코드의 실행 결과는 어떻게 될까?

// 먼저 함수 print 는 전역에 선언이 되었고, 함수 innerPrint는 함수 print 내부에 선언되었다.

// 렉시컬 스코프는 선언했을때 스코프가 결정되므로, 함수 print 의 상위 스코프는 전역 스코프이고, 함수 innerPrint 의 상위 스코프는 함수 print 의 지역 스코프가 된다.

// 함수 print 가 실행되고, 함수 내부의 innerPrint가 실행 된다.
// 그리고 함수 innerPrint 내부의 console.log(a,b) 가 실행 된다.
// 함수 innerPrint 스코프에서 변수 a,b 를 찾으려고 한다.
// a,b가 해당 스코프에서 찾을 수가 없어 상위 스코프로 올라간다.
// 상위 스코프인 함수 print 스코프에서 b 의 값을 찾았다.
// 여전히 a는 찾을 수가 없어 더 상위 스코프인 전역 스코프로 올라간다.
// 전역 스코프에서 변수 a 를 찾는데 성공했다.
// a = 1 , b = 2 , 출력 결과는 1,2 가 된다.
// 이렇게 변수를 찾을때까지, 상위스코프로 거슬러 올라간다. 그리고 가장 최상위인 전역스코프에서도 변수를 찾지 못한다면, Reference Error 가 될 것이다.

// 이렇게 스코프가 마치 체인처럼 연결되있다고 해서 이것을 스코프 체인이라고 한다. 